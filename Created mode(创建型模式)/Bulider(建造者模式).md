建造者模式
产品是由多个部件构成的，各个部件可以灵活选择，但其创建步骤都大同小异。这类产品的创建无法用前面介绍的工厂模式描述。
只有建造者模式可以很好地米哦啊书该产品的创建。

1.模式的定义与特点
建造者(Builder)模式的定义：指将一个复杂对象的构造与它的表现分离，使同样的构建过程可以创建不同的表示。
它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是
不变的，但每一部分是可以灵活选择的。

该模式的主要优点如下：
1.各个具体的建造者相互独立，有利于系统的扩展。
2.客户端不必知道产品内部组成的细节，便于控制细节风险。

缺点如下：
1.产品的组成部分必须相同，这限制了其使用范围。
2.如果产品的内部变化复杂，该模式会增加很多的建造者类。

建造者（Builer）模式和工厂模式的关注点不同：建造者模式注重零件的组装过程，而工厂方法模式更注重零件的创建过程，
但两者可以结合使用。

模式的应用场景
建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将他们组合在一起的算法却相对稳定，
所以它通常在以下场合使用。
创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。
创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。

模式的扩展
建造者（Builder）模式在应用过程中可以根据需要改变，如果创建的产品种类只有一种，只需要一个具体建造者，这时可以省略掉
抽象建造者，甚至可以省略掉指挥者角色。

Java中出现No enclosing instance of type XXX is accessible问题

Java编写代码过程中遇到了一个问题，main方法中创建内部类的实例时，编译阶段出现错误，查看错误描述：

Multiple markers at this line
 - The value of the local variable test is not used
 - No enclosing instance of type StaticCallDynamic is accessible. Must qualify the allocation with an enclosing instance of type StaticCallDynamic (e.g.
  x.new A() where x is an instance of StaticCallDynamic).
经过查证，是因为内部类是动态的（无static关键字修饰），而main方法是静态的，普通的内部类对象隐含地保存了一个引用，指向创建它的外围类对象，
所以要在static方法（类加载时已经初始化）调用内部类的必须先创建外部类。即应该这样创建“DanymicTest test = new StaticCallDynamic().new DanymicTest();”
其中StaticCallDynamic为外部类，DanymicTest为内部动态类；如果将内部内修改为静态类，可以在main中直接创建内部类实例。
　　顺便看了下静态方法对动态方法的调用，如果在静态方法中直接调用静态方法，其中print()为类中的动态方法，会出现如下问题：
Cannot make a static reference to the non-static method print() from the type StaticCallDynamic
　　这个要从java的内存机制去分析，首先当你New 一个对象的时候，并不是先在堆中为对象开辟内存空间，
而是先将类中的静态方法（带有static修饰的静态函数）的代码加载到一个叫做方法区的地方，然后再在堆内存中创建对象。
所以说静态方法会随着类的加载而被加载。当你new一个对象时，该对象存在于对内存中，this关键字一般指该对象，但是如果没有new对象，而是通过类名调用该类的静态方法也可以。
　　程序最终都是在内存中执行，变量只有在内存中占有一席之地时才会被访问，类的静态成员（变态和方法）属于类本身，
在类加载的时候就会分配内存，可以通过类名直接去访问，非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建实例）的时候才会分配内存，然后通过类的对象去访问。
在一个类的静态成员中去访问非静态成员之所以会出错是因为在类的非静态成员不存在的时候静态成员就已经存在了，访问一个内存中不存在的东西当然会出错。
　　所以要么将方法也改为静态方法，要么通过创建该方法所在的实例再通过实例来调用。