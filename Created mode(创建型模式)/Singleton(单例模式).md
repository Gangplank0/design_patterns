单例模式笔记
1.单例模式的定义与特点
  指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例子：Windows中只能打开一个任务管理器。
  单例模式有3个特点：
  单例类只有一个实例对象;
  该单例对象必须由单例类自行创建;
  单例类对外提供一个访问该单例的全局访问点;

2.单例模式的机构与实现
普通类的构造函数是公有的，外部类可以通过“new构造函数（）”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就是无法生成多个实例。
这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。

3.volatile和synchronized的特点
  执行控制的目的是控制代码执行（顺序）及是否可以并发执行
内存可见控制的是线程执行结果在内存中对其他线程的可见性。根据java内存模型的实现，线程在具体执行时，会先拷贝主存数据到线程本地（CPU缓存）
操作完成后再把结果从线程本地刷到主存。
synchronized关键字解决的是执行控制的问题，它会阻止其它线程获取当前对象的监控锁，这样就使得当前对象被synchronized关键字保护的代码无法被其他线程访问，
也就无法并发执行。更重要的是，synchronized还会创建一个内存屏障，内存屏障指令保证了所有CPU操作结果都会直接刷到主存中，从而保证了操作的内存可见性，同时也使得先获得这个锁的线程的所有操作，都happens-before于随后获得这个锁的线程的操作。
  volatile关键字解决的是内存可见性的问题，会使得所有对volatile变量的读写都会直接刷到主存，即保证了变量的可见性。这样就能满足一些对变量可见性有要求而对读取顺序没有要求的需求。
使用volatile关键字仅能实现对原始变量(如boolen、 short 、int 、long等)操作的原子性，但需要特别注意， volatile不能保证复合操作的原子性，即使只是i++，实际上也是由多个原子操作组成：read i; inc; write i，假如多个线程同时执行i++，volatile只能保证他们操作的i是同一块内存，但依然可能出现写入脏数据的情况。

4.volatile和synchronized的区别
volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化

5.单例模式的应用场景
前面分析了单例模式的结构与特点，以下是它通常适用的场景的特点。
在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。
当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。
当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。